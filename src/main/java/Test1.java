import com.rd.hcb.math.Test;

import java.util.List;

/**
 * @author zlx
 * @date 2019-11-19 10:40
 */
public class Test1 {

    public static int getNum(int n) {
        if (n <= 2) return n;
        int a = 1;//只有1级台阶的情况
        int b = 2;//有2级台阶的情况
        int tmp = 0;//辅助变量
        for (int i = 3; i <= n; i++) {
            tmp = a + b;
            a = b;
            b = tmp;
        }
        return tmp;
    }

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        System.out.println(getNum(6));
    }

    /**
     *
     * 　内存按访问方式来看，其结构就如同上面的长方形带子，地址依次升高。为了解释问题更明白，我们假设还在实模式下，
     * 如果读者不清楚什么是实模式也不要紧，这并不影响理解段是什么，故暂且先忽略。
     *
     * 　　内存是随机读写设备，即访问其内部任何一处，不需要从头开始找，只要直接给出其地址便可。如访问内存0xC00，
     * 只要将此地址写入地址总线便可。问题来了，分段是内存访问机制，是给cpu用的访问内存的方式。只有cpu才关注段。
     * 那为什么cpu要用段呢，也就是为什么cpu非得将内存分成一段一段的才能访问呢。说来话长，
     * 现实行业中有很多问题都是历史遗留问题，计算机行业也不能例外。这分段是从cpu 8086开始的，限于技术和经济，
     * 那时候电脑还是非常昂贵的东西，所以cpu和寄存器等宽度都是16位的，并不是像今天寄存器已经扩展到64位，
     * 当然编译器用的最多的还是32位。16位寄存器意味着其可存储的数字范围是2的16次方，即65536字节，64k。
     * 那时的计算机没有虚拟地址之说，只有物理地址，访问任何存储单元都直接给出物理地址。
     *
     * 　　编译器在编译程序时，肯定要根据cpu访问内存的规则将代码编译成机器指令，这样编译出来的程序才能在该cpu上运行无误，
     * 所以说，在直接以绝对物理地址访问内存的cpu上运行程序，该程序中指令的地址也必须得是绝对物理地址。
     * 总之，要想在该硬件上运行，就要遵从该硬件的规则，操作系统和编译器也无一例外。
     *
     * 　　若加载程序运行，不管其是内核程序还是用户程序，程序中的地址若都是绝对物理地址，
     * 那该程序必须放在内存中固定的地方，于是乎，两个编译出来地址相同的用户程序还真没法同时运行，
     * 只能运行一个。于是伟大的计算机前辈们用分段的方式解决了这一问题，让cpu采用段基址+段内偏移地址的方式来访问任意内存。
     * 这样的好处是，程序可以重定位了，尽管程序指令中给的是绝对物理地址，但终究可以同时运行多个程序了。
     *
     * 　　什么是重定位呢，简单来说就是将程序中指令的地址改写成另外一个地址，但该地址处的内容还是原地址处的内容。
     * cpu采用“段基址+段内偏移地址”的形式访问内存，就需要专门提供个段基址寄存器，这些是cs、ds、es等。
     * 程序中需要用到哪块内存，只要先加载合适的段加址到段基址寄存器中，再给出相对于该段基址的偏移地址便可，
     * cpu中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。
     * 注意，很多同学都觉得段基址一定得是65536的倍数（16位段基址寄存器的容量），这个真的不用，段基址可以是任意的。
     * 这就是段可以重叠的原因。
     *
     * 　　举个例子，看图0-2，假设段基址为0xc00,要想访问物理内存0xc01，就要将用0xc00:0x01的方式来访问才行。
     * 若将段基址改为0xc01，还是访问0xc01，就要用0xc01:0x00的方式来访问。同样，若想访问物理内存0xc04，
     * 段基址和段内偏移的组合可以是：0xc01:0x03、0xc02:0x02、0xc00:0x04等等，总之要想访问某个物理地址，
     * 只要凑出合适的段基地址和段内偏移地址，其和为该物理地址就行啦。这时估计有人会问这样行不行，0xc05:-1，
     * 能这样提问的同学都是求知欲极强的，你可以自己试一下啦。
     *
     * 　　说了这么多，我想告诉你的是，只要程序分了段，把整个段平移到任何位置后，段内的地址相对于段基址是不变的，
     * 无论段基址是多少，只要给出段内偏移地址，cpu就能访问到正确的指令。于是加载用户程序时，
     * 只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无误的运行，
     * 因为程序中用的是段内偏移地址，相对于新的段基址，该偏移地址处的内存内容还是一样的。如图0-3所示：
     *
     *
     * 图0-3 段的重定位
     *
     * 　　所以说，程序分段是首先是为了重定位，我说的是首先，下面还有理由呢。
     * 偏移地址也要存入寄存器，而那时的寄存器是16位的，也就是一个段最多可以访问到64K。
     * 而那时的内存再小也有1M呢，这样通过改变段基址的方式，由一个段变为另一个段，就像一个段在内存中飘移，
     * 采用这种在内存中来回挪位置的方式来访问到任意内存位置。所以说，程序分段又是为了将大内存分成可以访问的小段，
     * 通过这样变通的方法便能够访问到所有内存了。
     *
     * 　　但想一想，1M内存是2的20次方，即需要20位的地址才能访问到，如何做到16位寄存器访问20位地址空间呢？
     * 在8086的寻址方式中，有基址寻址，这是用基址寄存器bx或bp来提供偏移地址。
     * 如mov [bx], 0x5;这条指令便是将立即数0x5存入ds:bx指向的内存。大家看，bx寄存器是16位的，
     * 它最大只能表示0~0xFFFF的地址空间，即64K，也就是单一的一个寄存器无法表示20位的地址空间——1M。
     * 也许有人会说，段基址和段内偏移地址都搞到最大，都为0xFFFF，对不起，即使不溢出的话，
     * 其结果也只是由16位变成了17位，即两个n位的数字无论多大，其相加的结果也超不过n+1位，
     * 因为即使是两个相同的数相加，其结果相当于乘以2，也就是左移一位而已，依然无法访问20位的地址空间。
     * 也许有同学又有好建议了：cpu的寻址方式又不是仅仅这一种，上面的限制是因为寄存器是16位，
     * 只要不全部通过寄存器不就行了吗。既然段寄存器必须得用，那就在偏移地址上下功夫，
     * 不要把偏移地址写在寄存器里了，把它直接写成20位立即数不就行啦。如mov ax, [0x12345]，
     * 这样最终的地址是ds+0x12345，肯定是20位，解决啦。不错，这种是直接寻址方式，至少道理上讲得通，
     * 这是通过编程技巧来突破这一瓶颈，能想到这一点我觉得非常nice。但是做为一个严谨的cpu，
     * 既然宣称支持了通过寄存器来寻址，那就要能够自圆其说才行，不能靠程序员的软实力来克服cpu自身的缺陷
     * 。于是，一个大胆的想法出现了。16位的寄存器最多访问到64k大小的内存。虽然1M内存中可容纳1M/64k=16个最大段，
     * 但这只是可以容纳而已，并不是说可以访问到。16位的寄存器超过0xffff后将会回卷到0，又从0重新开始。
     * 20位宽度的内存地址空间必然只能由20位宽度的地址来访问。
     * 问题又来了，在当时只有16位寄存器的情况下是如何做到访问20位地址空间的呢。
     * 这是cpu设计者在地址处理单元中动了手脚，该地址部件接到“段基址+段内偏移地址”的地址后，
     * 自动将段基址乘以16，即左移了4位，然后再和16位的段内偏移地址相加，这下地址变成了20位了吧，
     * 行啦，有了20位的地址便可以访问20位的空间，可以在1M空间内自由翱翔了
     *
     *
     * 寄存器寻址
     *        当操作数不放在内存中，而是放在CPU的寄存器中时，
     * 从寄存器中取操作数的方式称为寄存器寻址。寄存器寻址也分为寄存器间接寻址和寄存器直接寻址，
     * 两者的区别在于：寄存器间接寻址方式的指令格式中的寄存器内容不是操作数，
     * 而是操作数的地址，该地址指明的操作数在内存中。
     *
     * mov ax, bx      ;寄存器直接寻址
     * mov ax, [bx]    ;寄存器间接寻址
     * 立即数寻址
     *        立即数寻址的源操作数是常数，之所以叫立即数，
     * 是相对于其他寻址方式中处理器需要从寄存器或内存中获取操作数的方式而言的。
     * 立即数寻址中指令的地址字段指出的不是操作数的地址，而是操作数本身。
     * 立即寻址方式的特点是指令执行时间很短，因为它不需要访问内存取数，从而节省了访问内存的时间。
     *
     * 内存寻址
     *        相对于寄存器寻址的操作数在寄存器中和立即数寻址的操作数直接在指令中，
     * 操作数需要在内存中寻找的方式成为内存寻址。可供程序员操纵的寄存器数量有限，
     * 当操作数很多的时候采用寄存器寻址方式显得捉襟见肘。
     * 而立即数寻址必须提前知道立即数是多少，否则不可用，
     * 且大多数时候操作数位于内存中的某个位置，
     * 只知道操作数所在的内存地址而不知道操作数的值就更谈不上将其变为立即数用在指令中了。
     * 因此内存寻址的存在也就成了理所当然。
     *
     *        在实模式下，访问内存时用“段基址: 段内偏移地址”的形式。
     * 默认情况下数据段寄存器是ds，即段基址已经有了，
     * 只要再给出段内偏移地址就可以访问内存了，最终起决定作用的、
     * 有效的是段内偏移地址，所以段内偏移地址称为有效地址。
     *
     * 直接寻址
     *        直接寻址就是直接在操作数中给出的数字作为内存地址，
     * 通过中括号的形式告诉CPU取此地址作为操作数。
     * 直接寻址和立即数寻址的区别在于，立即数寻址中的数字是直接拿来用作操作数，
     * 而直接寻址中的数字则是用来进一步寻址的。
     *
     * 基址寻址
     *        基址寻址就是在操作数中用基址寄存器（在实模式下只能用bp和bx寄存器）作为地址的起始，
     * 地址的变化以它为基础。就是将CPU中的基址寄存器的内容，加上变址寄存器的内容而形成操作数的有效地址。
     *
     * add word[bx], 0x1234    ;将0x1234加上内存地址ds:bx处的值后再存入内存地址ds:bx中
     *        基址寻址的优点是可以扩大寻址能力，因为与形式地址相比，
     * 基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址。
     *
     * 变址寻址
     *        变址寻址和基址寻址类似，只是寄存器由bx、bp换成了si、和di。
     *
     * mov [di], ax    ;将寄存器ax的值存入ds:di指向的内存
     * 基址变址寻址
     *        基址寻址和变址寻址的结合，即基址寄存器bx或bp加上变址寄存器si或di。
     *
     * mov [bx+di], ax    ;将ax中的值存入以ds为段基址，bx+di为偏移地址的内存中

     */





}



